#!/usr/bin/env python
#
# 2014/11/10  Sean Dobbs (s-dobbs@northwestern.edu)
#
# This script should be run after offline monitoring ROOT files are generated
#

import sys,os
from os import listdir
from os.path import isfile, join
from math import fabs
import struct
from datetime import datetime
#import numpy as np

from datamon_db import datamon_db

RADIATOR_TOLERANCE = 5  # allow 5 mm tolerance in determining which radiator

def EVIO_SWAP64(x):
    return ( (((x) >> 56) & 0x00000000000000FFL) | \
                 (((x) >> 40) & 0x000000000000FF00L) | \
                 (((x) >> 24) & 0x0000000000FF0000L) | \
                 (((x) >> 8)  & 0x00000000FF000000L) | \
                 (((x) << 8)  & 0x000000FF00000000L) | \
                 (((x) << 24) & 0x0000FF0000000000L) | \
                 (((x) << 40) & 0x00FF000000000000L) | \
                 (((x) << 56) & 0xFF00000000000000L) )


def EVIO_SWAP32(x):
    return ( (((x) >> 24) & 0x000000FF) | \
                 (((x) >> 8)  & 0x0000FF00) | \
                 (((x) << 8)  & 0x00FF0000) | \
                 (((x) << 24) & 0xFF000000) )


# set default values
def init_property_mapping():
    run_properties = {
        'status'           : '-1',
        'start_time'       : '<None>',
        'end_time'         : '<None>',
        'num_files'        : '1',
        'num_events'       : '-1',
        'beam_energy'      : '10.1',       # hardcoded in GeV for now
        'beam_current'     : '-1',
        'radiator_type'    : '<None>',
        'luminosity'       : '-1',
        'solenoid_current' : '-1',
        'coherent_peak'    : '-1',
        'target_type'      : '<None>'
    }
    return run_properties

# go from timestamp to string
def format_date(timestamp):
    dt = datetime.fromtimestamp(timestamp)
    return str(datetime(dt.year,dt.month,dt.day,dt.hour,dt.minute,dt.second))

# parse files generated by run_epics_info.py
# ignore lines that begin with '#'
# look for lines that look like:   KEY = VALUE
def parse_condition_file(fname):
    run_conditions = {}
    try:
        infile = open(fname)
        for line in infile:
            tokens = line.strip().split()
            if len(tokens)==0 or tokens[0][0] == '#':
                continue
            if len(tokens)<3:
                continue
            if tokens[1] == "=":
                # deal with special cases
                if tokens[0] == "TIME":
                    run_conditions[ tokens[0] ] = " ".join(tokens[2:])
                else:
                    run_conditions[ tokens[0] ] = tokens[2]
        infile.close()
    except IOError as e:
        print "I/O error({0}): {1}".format(e.errno, e.strerror)
        return None
        #sys.exit(0)
    except:
        print "Unexpected error:", sys.exc_info()[0]
        return None
        #sys.exit(0)
    return run_conditions


# algorithm taken from evio2db
def ParseEVIOFiles(filelist):
    BUFFER_SIZE_WORDS = 1000  
    all_properties = []
    # should double check file names
    for fnamepath in filelist:
        print "processing " + fnamepath + "..."
        try:
            # extract file number & check 
            fname = fnamepath.split('/')[-1]
            if len(fname) < 6 or fname[-5:] != ".evio":
                print "bad file " + fname + " , skipping..."
                continue
            fparts = fname[:-5].split('_')
            if len(fparts) < 4:
                print "bad file " + fname + " , skipping..."
                continue
            try:
                file_num = int(fparts[3])
            except ValueError:
                print "bad file " + fname + " , skipping..."
                continue                

            filesize = os.path.getsize(fnamepath)
            f = open(fnamepath,"rb")
            # initialize values
            properties = {}
            properties["file_num"] = file_num
            # figure out the first event
            in_words = BUFFER_SIZE_WORDS
            if filesize < BUFFER_SIZE_WORDS:
                in_words = filesize/4
            data_in = f.read(4*in_words)
            data = struct.unpack(str(in_words)+"I", data_in)
            for i in xrange(len(data)):
                w = data[i]
                # Look for a "Go" event that we can use for the beginning of the run
                if( (w & 0x0001D2FF) == 0x0001D2FF ): 
                    properties["start_time"] = EVIO_SWAP32(data[i+1]);
                # Physics Event Header bits that should be set
                if( (w & 0x001050FF) != 0x001050FF ):
                    continue
                # Physics Event Header bits that should not be set
                if( (w & 0x000F0E00) != 0x00000000 ):
                    continue
                # Jump 2 words to Trigger bank
                w = data[i+2];
                # Built Trigger Bank bits that should be set
                if( (w & 0x002020FF) != 0x002020FF ):
                    continue
                # First bank in Trigger bank should be 64bit int type
                w = data[i+3];
                if( (w & 0x00000A00) != 0x00000A00 ):
                    continue
                        
                properties["first_event"]  = EVIO_SWAP64( (long(data[i+5])<<32) | long(data[i+4]) )
                properties["tfirst_event"] = EVIO_SWAP64( (long(data[i+7])<<32) | long(data[i+6]) )
                break

            # figure out the last event - search through the file in chunks from the back
            n = 0  # number of chunks we have looked through
            last_event = 0
            while True:
                if(last_event > 0):
                    break
                n += 1
                f.seek(-n*4*in_words, 2)
                data_in = f.read(4*in_words)
                Nwords = len(data_in)/4
                data = struct.unpack(str(in_words)+"I", data_in)                
                #for i in xrange(len(data)):
                i = Nwords - 7
                while True:
                    i -= 1
                    if i < 0:
                        break
                    w = data[i]
                    # Physics Event Header bits that should be set
                    if( (w & 0x001050FF) != 0x001050FF ):
                        continue
                    # Physics Event Header bits that should not be set
                    if( (w & 0x000F0E00) != 0x00000000 ):
                        continue
                    # Jump 2 words to Trigger bank
                    w = data[i+2];
                    # Built Trigger Bank bits that should be set
                    if( (w & 0x002020FF) != 0x002020FF ):
                        continue
                    # First bank in Trigger bank should be 64bit int type
                    w = data[i+3];
                    if( (w & 0x00000A00) != 0x00000A00 ):
                        continue

                    last_event = EVIO_SWAP64( (long(data[i+5])<<32) | long(data[i+4]) )
                    properties["last_event"]  = last_event
                    properties["tlast_event"] = EVIO_SWAP64( (long(data[i+7])<<32) | long(data[i+6]) )
                    break

            # calculate results for a file
            N = (properties["last_event"] - properties["first_event"]) + 1
            if N == 0:
                N = 1
            end_time = 5.0E-9 * (float(properties["tlast_event"]) - float(properties["tfirst_event"]))
            properties["num_events"] = N
            properties["end_time"] = end_time

            # we're all done!
            all_properties.append(properties)

        except IOError as e:
            print "I/O error({0}): {1}".format(e.errno, e.strerror)
            return {}

    # build results
    file_properties = {}
    file_properties["num_files"] = len(all_properties)
    file_properties["num_events"] = -1
    file_properties["start_time"] = -1
    file_properties["end_time"] = -1
    for props in sorted(all_properties, key=lambda prop: int(prop["file_num"])):
        if file_properties["start_time"] < 0 :
            file_properties["start_time"] = props["start_time"]
            file_properties["end_time"] = props["start_time"] + props["end_time"]
            file_properties["num_events"] = props["num_events"]
        else:
            file_properties["end_time"] += props["end_time"] 
            file_properties["num_events"] += props["num_events"] 
    file_properties["start_time"] = format_date(file_properties["start_time"])
    file_properties["end_time"] = format_date(file_properties["end_time"])
    return file_properties

def main(argv):
    # configuration vars
    RUN_PERIOD = "RunPeriod-2014-10"
    CONDITION_FILE_FORMAT = "/work/halld/online_monitoring/conditions/run_conditions%06d.dat"
    # assume that the files are loaded on the cache disk
    RAWDATA_DIR_FORMAT = "/cache/mss/halld/RunPeriod-2014-10/rawdata/Run%06d"

    # read in run number from command line
    try:
        run_number = int(argv[0])
    except:
        print "Need to pass the run number to process as a command line argument!"
        return

    run_properties = init_property_mapping()

    run_conditions = parse_condition_file(CONDITION_FILE_FORMAT % (run_number))
    if run_conditions is None:
        return

    # start extracting saved EPICS values
    #run_number = run_conditions['RUN']     ## check this?
    run_properties['beam_current'] = run_conditions['IBCAD00CRCUR6']
    run_properties['start_time'] = run_conditions['TIME']
    run_properties['solenoid_current'] = run_conditions['HallD-PXI:Data:I_Shunt']

    # figure out which radiator was used
    # save luminosity factor = current * radiator thickness
    amorphous_radiator_position = float(run_conditions['hd:radiator:motor.RBV'])
    if fabs(amorphous_radiator_position - 135.948) < RADIATOR_TOLERANCE:
        run_properties['radiator_type'] = '2x10-5 RL'
        run_properties['luminosity'] = 1.7e-5 * float(run_properties['beam_current'])
    elif fabs(amorphous_radiator_position - 166.095) < RADIATOR_TOLERANCE:
        run_properties['radiator_type'] = '1x10-4 RL'
        run_properties['luminosity'] = 11.2e-5 * float(run_properties['beam_current'])
    elif fabs(amorphous_radiator_position - 196.262) < RADIATOR_TOLERANCE:
        run_properties['radiator_type'] = '3x10-4 RL'
        run_properties['luminosity'] = 22.7e-5 * float(run_properties['beam_current'])
    else:
        run_properties['luminosity'] = run_properties['solenoid_current']

    # parse EVIO files to extract useful information
    # eventually the DAQ will report this properly?
    rawdata_evio_dir = RAWDATA_DIR_FORMAT % (run_number)
    print "rawdata_evio_dir = " + str(rawdata_evio_dir)
    if os.path.isdir(rawdata_evio_dir) :
        filelist = [ join(rawdata_evio_dir,f) for f in listdir(rawdata_evio_dir) if ((f[:10]=="hd_rawdata" or f[:6]=="hd_raw")and(f[-5:]=='.evio')) ]
        print "FILELIST = " + str(filelist)
        file_properties = ParseEVIOFiles(filelist)
        if len(file_properties) > 0:
            run_properties['num_events'] = file_properties['num_events']
            run_properties['num_files'] = file_properties['num_files']
            run_properties['start_time'] = file_properties['start_time']
            run_properties['end_time'] = file_properties['end_time']

    print "RUN PROPERTIES FOR RUN " + str(run_number)
    print str(run_properties)

    # Add information to DB
    ## initialize DB
    db = datamon_db()
    ## add blank run to DB if it doesn't exist
    if(db.GetRunID(run_number) < 0):
        db.CreateRun(run_number)
    db.UpdateRunInfo(run_number, run_properties)

if __name__ == "__main__":
    main(sys.argv[1:])
