#include <inttypes.h>
#include <iostream>
#include <fstream>
#include <utility>
#include <vector>
#include <map>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <cstring>
#include <sstream>

#include "TLatex.h"
#include "TPaveStats.h"
#include "TGraphPainter.h"
#include "TString.h"
#include "TCollection.h"
#include "TCanvas.h"
#include "TFile.h"
#include "TH1F.h"
#include "TF1.h"
#include "TGraph.h"
#include "TGraphErrors.h"
#include "TMinuit.h"
#include "TKey.h"
#include "TDatime.h"
#include "TAxis.h"
#include "TLine.h"
#include "TTree.h"
#include "TBranch.h"
#include "TStyle.h"
#include "TProfile.h"
#include "TSystem.h"
//root -l -q -b 'PlotTiming1.C+("../RunData/hd_rawdata_002153_000.evio.root","2153")'
void PlotTiming1(TString filename = "0", TString plotlabelst="default", 
								  Int_t numbins = 10000, Bool_t globalscale = 1, Bool_t test=0) {

	int VERBOSE = 3;
	//uint mincrate = 71, maxcrate = 77, minslot = 3, maxslot = 16, minchan = 0, maxchan = 15; //TAGM 71, TAGH 73, TOF 77
//	uint mincrate = 93, maxcrate = 94, minslot = 3, maxslot = 16, minchan = 0, maxchan = 15; //ST
uint mincrate = 11, maxcrate = 23, minslot = 3, maxslot = 19, minchan = 0, maxchan = 15; //FCAL
//	uint mincrate = 35, maxcrate = 35, minslot = 9, maxslot = 11, minchan = 0, maxchan = 15;

	int mintime = 0, maxtime = 10000;
	int difftime = maxtime - mintime;

	char plotlabel[255],pedyaxistitle[255],intyaxistitle[255];
	sprintf(plotlabel,"%s",plotlabelst.Data());
	sprintf(plotlabel,"%s",plotlabelst.Data());

	if (filename == "0" || plotlabelst == "default") {
		printf("\nUsage:\n\n\t.x PlotWidth_Df250Pulsetime.C+(TString filename, TString plotlabelst, Int_t numbins = 400, Bool_t globalscale = 1, Bool_t test=0)\n\n");
		printf("\t filename \t = %s\n",filename.Data());
		printf("\t plotlabel \t = %s\n",plotlabel);
		printf("\t numbins \t = %i\n",numbins);
		printf("\t globalscale \t = %i\n",globalscale);
		printf("\t test \t\t = %i\n\n",test);
		return;
	}


    gStyle->SetPalette(1,0);
    // gStyle->SetOptStat(kTRUE);
    gStyle->SetOptStat(kFALSE);
    // gStyle->SetOptFit(kTRUE);
    gStyle->SetOptFit(kFALSE);
    // gStyle->SetOptFit(11111);
   // gStyle->SetOptStat(2210);
    gStyle->SetPadRightMargin(0.05);
    gStyle->SetPadLeftMargin(0.17);
    gStyle->SetPadBottomMargin(0.15);
    gStyle->SetPadTopMargin(0.1);
    gStyle->SetFillColor(0);
    gStyle->SetTitleOffset(1.2, "Y");
	gStyle->SetTitleSize(0.07,"xyz");
	gStyle->SetTitleSize(0.08,"h");
	gStyle->SetLabelSize(0.07,"xyz");
	gStyle->SetTitleX(0);
	gStyle->SetTitleAlign(13);
	gStyle->SetNdivisions(505,"xy");

	gStyle->SetStatH(0.20);
	gStyle->SetStatW(0.36);
	gStyle->SetStatX(0.99);
	gStyle->SetStatY(0.99);



	char outdir[255];
	sprintf(outdir,"../plots/timing/%s",plotlabelst.Data());
	printf("\nCreating directory %s\n",outdir);

	Int_t result = gSystem->mkdir(outdir,1); // make directory recursively
	if (result != 0) {
		if (result == -1) {
			printf("Directory %s already exists\n\n",outdir);
		} else {
			printf("cannot make directory %s with result %i\n\n",outdir,result);
			exit(result);
		}
	} else {
		printf("\nCreated directory %s\n\n",outdir);	
	}


    // Read input file generated by DAQ and converted to ROOT using DAQTree plugin
    TFile* file = new TFile(filename.Data()); 
    TTree* tree = (TTree*)file->Get("Df250PulseTime");

	uint32_t channelnum;         ///< Arbitrary global channel number (sorted by crate, slot, channel).  Note that when data is sparsified then this value will not have a constant relationship with any particular physical channel.
	uint32_t eventnum;	         ///< Event number	
	uint32_t rocid;              ///< (from DDAQAddress) Crate number
	uint32_t slot;               ///< (from DDAQAddress) Slot number in crate
	uint32_t channel;            ///< (from DDAQAddress) Channel number in slot
	uint32_t itrigger;           ///< (from DDAQAddress) Trigger number for cases when this hit was read in a multi-event block (from DDAQAddress)
	uint32_t pulse_number;
	uint32_t quality_factor;
	uint32_t time;
	
	
    tree->SetBranchAddress("channelnum",&channelnum);
    tree->SetBranchAddress("eventnum",&eventnum);
    tree->SetBranchAddress("rocid",&rocid);
    tree->SetBranchAddress("slot",&slot);
    tree->SetBranchAddress("channel",&channel);
    tree->SetBranchAddress("itrigger",&itrigger);
    tree->SetBranchAddress("pulse_number",&pulse_number);
    tree->SetBranchAddress("quality_factor",&quality_factor);
	  tree->SetBranchAddress("time",&time);
	
	Long_t nsize = tree->GetEntries();
	Int_t startentrynum = 1;
	Int_t endentrynum = nsize;
    printf ("\nProcess entries %i to %i\n\n",startentrynum,endentrynum);

	int numrocs=100, numslots=22, numchans=17;
	TH1I *timehistos[numrocs][numslots][numchans];

    // ************
    // Loop Over Events in tree and fill historgrams
	// ************
	char histName[255],histTitle[255];

    for (Int_t entry=startentrynum; entry<endentrynum; entry++){
        tree->GetEntry(entry);
		if (entry%100000==0 || endentrynum-entry<5) {
			printf("Entry %10i    %2i %2i %2i   channelnum %4i  event %6i   time %6i\n",
				   entry,rocid,slot,channel,channelnum,eventnum,time);
		}
		// Only look at the interesting crates and slots
		if (rocid >= mincrate && rocid <= maxcrate && slot >= minslot && slot <= maxslot && channel >= minchan && channel <= maxchan ) {
			if (time>0) {
				// Crate histograms if they don't already exist
				if (timehistos[rocid][slot][channel]==NULL) {
					sprintf(histTitle,"Channel (R%i,S%i,C%i);hits",rocid,slot,channel);
					sprintf(histName,"time%02i%02i%02i",rocid,slot,channel);
					
					printf("creating histogram for (%2i,%2i,%2i):   %s   %s\n",rocid,slot,channel, histName,histTitle);
					
					timehistos[rocid][slot][channel] = new TH1I(histName,histTitle,difftime,mintime,maxtime);
					timehistos[rocid][slot][channel]->SetNdivisions(505);
					//if (VERBOSE>1) { printf("done\n"); }
				}
				printf("Entry %10i    %2i %2i %2i   channelnum %4i  event %6i  time %i\n",
				 	   entry,rocid,slot,channel,channelnum,eventnum,time);
				timehistos[rocid][slot][channel]->Fill(time);
			}
		}
	}
    // ************
    // Plot the histograms
	// ************
	TCanvas *pedcanvas = new TCanvas("pedcanvas","times",20,10,1500,900);
	pedcanvas->Divide(4,4,0.001,0.001);
	// TCanvas *intcanvas = new TCanvas("intcanvas","Integrals",20,10,1500,900);
	// intcanvas->Divide(4,4,0.001,0.001);

	bool drawslotpage = 0;
	char slotlabel[255];	
	char plotname[255];

	gStyle->SetTitleSize(0.06,"xyz");
	gStyle->SetTitleSize(0.07,"h");
	gStyle->SetLabelSize(0.06,"xyz");

	TH1I *timemean = new TH1I("timemean","Time MEAN;time mean",200,10,-10);
	TH1I *timerms = new TH1I("timerms","Time RMS;time RMS",200,10,-10);
		
	for (uint crateindex=mincrate; crateindex<=maxcrate; crateindex++){
		for (uint slotindex=minslot; slotindex<=maxslot; slotindex++){
			int padcounter=1;
			pedcanvas->Clear();
			pedcanvas->Divide(4,4,0.001,0.001);
	
			for (uint chanindex=minchan; chanindex<=maxchan; chanindex++){
				if (timehistos[crateindex][slotindex][chanindex]!=NULL) {
					int entries = timehistos[crateindex][slotindex][chanindex]->GetEntries();
					if (entries > 0) {
						drawslotpage=1;
						if (VERBOSE>1) printf("Plotting histogram (%2i,%2i,%2i) with %i entries\n",
											  crateindex,slotindex,chanindex,entries);
						pedcanvas->cd(padcounter);
						gPad->SetLogy();
						float min = timehistos[crateindex][slotindex][chanindex]->GetMinimum(10);
						timehistos[crateindex][slotindex][chanindex]->SetMinimum(min-0.5);
						timehistos[crateindex][slotindex][chanindex]->SetMarkerStyle(7);
						timehistos[crateindex][slotindex][chanindex]->Draw();
						float mean = timehistos[crateindex][slotindex][chanindex]->GetMean();
						float RMS = timehistos[crateindex][slotindex][chanindex]->GetRMS();
						timemean->Fill(mean);
						timerms->Fill(RMS);
						padcounter++;
					} else {
						if (VERBOSE>1) printf("Histogram (%2i,%2i,%2i) no entries\n",crateindex,slotindex,chanindex);
					}
				} else {
					if (VERBOSE>1) printf("No histogram (%2i,%2i,%2i)\n",crateindex,slotindex,chanindex);
				}
			}
			// if this slot has histograms then draw the page
			if (drawslotpage) {
				pedcanvas->Update();
				sprintf(plotname,"%s/timewidth_%s_R%02iS%02i.png",outdir,plotlabel,crateindex,slotindex);
				pedcanvas->Print(plotname);
				drawslotpage=0;
			} else {
				if (VERBOSE>1) printf("Nothing to print for crate %2i, slot %2i.\n",crateindex,slotindex);
			}
		}
	}

	//gStyle->SetOptStat(kFALSE);

    gStyle->SetPadRightMargin(0.15);
    gStyle->SetPadLeftMargin(0.13);
    gStyle->SetPadBottomMargin(0.12);

	TCanvas *smallcan = new TCanvas("smallcan","smallcan",800,600);

	timemean->Draw();
	sprintf(plotname,"%s/timemean.png",outdir);
	smallcan->Print(plotname);
	timerms->Draw();
	sprintf(plotname,"%s/timeRMS.png",outdir);
	smallcan->Print(plotname);

}


/* emacs
 * Local Variables:
 * mode:C++
 * mode:font-lock
 * c-file-style: "stroustrup"
 * tab-width: 4
 * End:
 */
